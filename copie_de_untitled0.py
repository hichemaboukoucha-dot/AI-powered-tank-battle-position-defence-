# -*- coding: utf-8 -*-
"""Copie de Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LrgMNY4ffkszlHlUb0JMbIHBSMRNrsYo
"""

import asyncio
import platform
import pygame
import numpy as np
import random
from collections import deque
import sys

# Initialize Pygame
pygame.init()

# Constants
WIDTH, HEIGHT = 500, 500
FPS = 60
PARTICLE_RADIUS = 10
HALO_RADIUS_SCALE = 50
GOAL_POS = np.array([WIDTH / 2, HEIGHT - 50.0])  # Goal at bottom center
TRAIL_LENGTH = 20  # Number of positions to keep for trails
TRAIL_ALPHA_STEP = 255 // TRAIL_LENGTH  # Fade effect for trails
COMMENTARY_CYCLE_TIME = 3.0  # Seconds to display each particle's commentary
SHOOT_COOLDOWN = 1.0  # Seconds between shots for circles
PUSH_STRENGTH = 100.0  # Velocity push from shot

# Colors
WHITE = (255, 255, 255)
RED = (255, 0, 0)  # Circles
BLUE = (0, 0, 255)  # X points
GREEN = (0, 255, 0)  # Goal
YELLOW = (255, 255, 0)  # Halos
BLACK = (0, 0, 0)  # Text
SHOOT_COLOR = (255, 100, 0)  # Orange for shoot lines

# Particle class
class Particle:
    def __init__(self, pos, is_circle):
        self.pos = np.array(pos, dtype=float)
        self.is_circle = is_circle
        self.velocity = np.array([0.0, 0.0])
        self.feedback = 0.0  # Feedback from goal
        self.trail = deque(maxlen=TRAIL_LENGTH)  # Store recent positions for trail
        self.shoot_timer = 0.0 if is_circle else None  # Only circles shoot

    def update_position(self, dt):
        self.trail.append(self.pos.copy())  # Save current position for trail
        self.pos += self.velocity * dt
        # Keep particles within bounds
        self.pos = np.clip(self.pos, PARTICLE_RADIUS, [WIDTH - PARTICLE_RADIUS, HEIGHT - PARTICLE_RADIUS])

# Global variables
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()
font = pygame.font.SysFont('arial', 20)
particles = [
    # Circles (start at top)
    Particle([100, 50], True),
    Particle([250, 50], True),
    Particle([400, 50], True),
    # X points (start between circles and goal)
    Particle([100, 250], False),
    Particle([250, 250], False),
    Particle([400, 250], False)
]
paused = False  # Pause state
sv_history = []  # Store (circle_SV, x_point_SV) over time
commentary_index = 0  # Current particle for commentary
commentary_timer = 0.0  # Time since last commentary switch
current_shots = []  # List of (shooter_pos, target_pos) for drawing this frame

def compute_distance(p1, p2):
    return np.linalg.norm(p1.pos - p2.pos)

def danger_function(particle, enemies):
    # J: Sum of squared distances to enemies
    return sum(compute_distance(particle, enemy) ** 2 for enemy in enemies)

def cohesion(group):
    # D: Average pairwise distance within group
    if len(group) < 2:
        return 0
    distances = [compute_distance(p1, p2) for i, p1 in enumerate(group) for p2 in group[i+1:]]
    return np.mean(distances) if distances else 0

def probability_chosen(particle, enemies):
    # cp: Probability based on inverse distance to enemies
    distances = [compute_distance(particle, enemy) for enemy in enemies]
    total_inv_dist = sum(1 / (d + 1e-6) for d in distances)  # Avoid division by zero
    return total_inv_dist / (len(distances) + 1e-6)

def vulnerability(group, enemies):
    # V: Based on cohesion and probability of being chosen
    D = cohesion(group)
    cp_sum = sum(probability_chosen(p, enemies) for p in group)
    return D * cp_sum + 1e-6  # Avoid division by zero

def heat_function(particle, goal_pos, time_elapsed):
    # Heat: E (emitted signal) + R (response signal)
    E = 1.0 / (compute_distance(particle, goal_pos) + 1e-6)  # Emitted signal from goal
    # R: Space/time gained + feedback
    space_gain = 1.0 / (compute_distance(particle, goal_pos) + 1e-6)
    time_gain = 0.01 * time_elapsed
    R = space_gain + time_gain + particle.feedback
    return E + R

def strength(group, time_elapsed):
    # S: Sum of heat functions for the group
    return sum(heat_function(p, GOAL_POS, time_elapsed) for p in group)

def team_performance(circles, x_points, time_elapsed):
    # S/V for each team
    circle_S = strength(circles, time_elapsed)
    x_point_V = vulnerability(x_points, circles)
    circle_SV = circle_S / x_point_V if x_point_V != 0 else float('inf')

    x_point_S = strength(x_points, time_elapsed)
    circle_V = vulnerability(circles, x_points)
    x_point_SV = x_point_S / circle_V if circle_V != 0 else float('inf')

    return circle_SV, x_point_SV

def halo_radius(particle, enemies):
    # Hr: Based on J, D, and cp
    J = danger_function(particle, enemies)
    group = [p for p in particles if p.is_circle == particle.is_circle]
    D = cohesion(group)
    cp = probability_chosen(particle, enemies)
    return HALO_RADIUS_SCALE * (J / (D * cp + 1e-6)) ** 0.5

def choose_target(particle, enemies, time_elapsed):
    # Choose target based on halo radii, J, D, H, and contribution to enemy S
    scores = []
    for enemy in enemies:
        J = danger_function(particle, enemy)
        group = [p for p in particles if p.is_circle == particle.is_circle]
        D = cohesion(group)
        H = heat_function(enemy, GOAL_POS, time_elapsed)
        Hr = halo_radius(enemy, [p for p in particles if p.is_circle != enemy.is_circle])
        score = J / (Hr + 1e-6) + D + H
        scores.append((enemy, score))
    return min(scores, key=lambda x: x[1])[0] if scores else enemies[0]

def get_commentary(particle, enemies):
    # Generate commentary based on J, D, cp, and Hr without implying direct enemy detection
    J = danger_function(particle, enemies)
    group = [p for p in particles if p.is_circle == particle.is_circle]
    D = cohesion(group)
    cp = probability_chosen(particle, enemies)
    Hr = halo_radius(particle, enemies)

    # Normalize values for relative comparison
    J_norm = min(J / (WIDTH ** 2 * len(enemies)), 1.0)  # Normalize by max possible J
    D_norm = min(D / WIDTH, 1.0)  # Normalize by max possible distance
    cp_norm = min(cp * 100, 1.0)  # Scale cp for readability
    Hr_norm = min(Hr / (HALO_RADIUS_SCALE * 10), 1.0)  # Normalize by max halo size

    # Determine particle type
    particle_type = "Circle" if particle.is_circle else "X Point"

    # Generate commentary based on relative values
    commentary = f"{particle_type} at ({int(particle.pos[0])}, {int(particle.pos[1])}): "
    if J_norm > 0.7:
        commentary += "Feels strong pressure from nearby threats. "
    elif J_norm < 0.3:
        commentary += "Senses minimal threat presence. "
    else:
        commentary += "Perceives moderate threat influence. "

    if D_norm > 0.7:
        commentary += "Feels isolated from allies. "
    elif D_norm < 0.3:
        commentary += "Senses strong team unity. "
    else:
        commentary += "Perceives moderate team cohesion. "

    if cp_norm > 0.7:
        commentary += "Feels highly exposed to danger. "
    elif cp_norm < 0.3:
        commentary += "Feels relatively safe from targeting. "
    else:
        commentary += "Senses moderate exposure to threats. "

    if Hr_norm > 0.7:
        commentary += "Aura of influence is very wide."
    elif Hr_norm < 0.3:
        commentary += "Aura of influence is narrow."
    else:
        commentary += "Aura of influence is moderate."

    return commentary

def predict_v_after_shot(shooter, target, all_circles, all_x, dt):
    # Hypothetical copies
    hypo_circles = [Particle(p.pos.copy(), True) for p in all_circles]
    hypo_x = [Particle(p.pos.copy(), False) for p in all_x]
    hypo_target = next(p for p in hypo_x if np.allclose(p.pos, target.pos))

    # Apply push velocity
    direction = hypo_target.pos - shooter.pos
    dist = np.linalg.norm(direction)
    if dist > 1e-6:
        direction /= dist
    hypo_target.velocity += direction * PUSH_STRENGTH

    # Simulate one step update position (velocity already set, no need for full velocity update)
    for p in hypo_x + hypo_circles:
        p.pos += p.velocity * dt

    # Compute new V for x_points
    new_V = vulnerability(hypo_x, hypo_circles)
    return new_V

def update_loop(time_elapsed):
    global commentary_index, commentary_timer, current_shots
    current_shots = []  # Clear previous shots

    if paused:
        return team_performance([p for p in particles if p.is_circle], [p for p in particles if not p.is_circle], time_elapsed)

    dt = 1.0 / FPS
    circles = [p for p in particles if p.is_circle]
    x_points = [p for p in particles if not p.is_circle]

    # Compute team performance
    circle_SV, x_point_SV = team_performance(circles, x_points, time_elapsed)
    sv_history.append((circle_SV, x_point_SV))  # Store S/V history

    # Shooting logic for circles
    for circle in circles:
        circle.shoot_timer -= dt
        if circle.shoot_timer <= 0:
            # Predict V for each possible target
            predicted_vs = []
            for target in x_points:
                predicted_V = predict_v_after_shot(circle, target, circles, x_points, dt)
                predicted_vs.append((target, predicted_V))

            if predicted_vs:
                # Choose target with max predicted V (max vulnerability for enemies)
                best_target, _ = max(predicted_vs, key=lambda x: x[1])

                # Shoot: apply push
                direction = best_target.pos - circle.pos
                dist = np.linalg.norm(direction)
                if dist > 1e-6:
                    direction /= dist
                best_target.velocity += direction * PUSH_STRENGTH

                # Record shot for drawing
                current_shots.append((circle.pos.copy(), best_target.pos.copy()))

                # Reset timer
                circle.shoot_timer = SHOOT_COOLDOWN

    # Update velocities (original logic)
    for particle in particles:
        enemies = x_points if particle.is_circle else circles
        target = choose_target(particle, enemies, time_elapsed)
        direction = target.pos - particle.pos
        dist = np.linalg.norm(direction)
        if dist > 1e-6:
            direction /= dist
        if particle.is_circle:
            # Circles move toward goal, weighted by S/V
            goal_direction = GOAL_POS - particle.pos
            goal_dist = np.linalg.norm(goal_direction)
            if goal_dist > 1e-6:
                goal_direction /= goal_direction
            # Maximize S/V
            particle.velocity = (goal_direction * 50 * circle_SV + direction * 20) / (1 + circle_SV)
        else:
            # X points defend goal, minimize circle S/V
            particle.velocity = direction * 30 / (1 + circle_SV)
            particle.feedback += 0.01 * compute_distance(particle, GOAL_POS)

    # Update positions
    for particle in particles:
        particle.update_position(dt)

    # Update commentary timer
    commentary_timer += dt
    if commentary_timer >= COMMENTARY_CYCLE_TIME:
        commentary_index = (commentary_index + 1) % len(particles)  # Cycle to next particle
        commentary_timer = 0.0

    return circle_SV, x_point_SV

def draw(circle_SV, x_point_SV):
    screen.fill(WHITE)

    # Draw trails
    for particle in particles:
        color = RED if particle.is_circle else BLUE
        for i, pos in enumerate(particle.trail):
            alpha = 255 - i * TRAIL_ALPHA_STEP  # Fade older positions
            trail_surface = pygame.Surface((PARTICLE_RADIUS * 2, PARTICLE_RADIUS * 2), pygame.SRCALPHA)
            pygame.draw.circle(trail_surface, (*color, alpha), (PARTICLE_RADIUS, PARTICLE_RADIUS), PARTICLE_RADIUS)
            screen.blit(trail_surface, (int(pos[0]) - PARTICLE_RADIUS, int(pos[1]) - PARTICLE_RADIUS))

    # Draw goal
    pygame.draw.circle(screen, GREEN, GOAL_POS.astype(int), 15)

    # Draw shoot lines
    for shooter_pos, target_pos in current_shots:
        pygame.draw.line(screen, SHOOT_COLOR, shooter_pos.astype(int), target_pos.astype(int), 3)

    # Draw particles and halos
    for particle in particles:
        color = RED if particle.is_circle else BLUE
        pygame.draw.circle(screen, color, particle.pos.astype(int), PARTICLE_RADIUS)
        # Draw halo
        enemies = [p for p in particles if p.is_circle != particle.is_circle]
        Hr = halo_radius(particle, enemies)
        pygame.draw.circle(screen, YELLOW, particle.pos.astype(int), int(Hr), 1)

    # Draw S/V scores, pause status, and commentary
    circle_text = font.render(f"Circles S/V: {circle_SV:.2f}", True, BLACK)
    x_point_text = font.render(f"X Points S/V: {x_point_SV:.2f}", True, BLACK)
    pause_text = font.render("Paused" if paused else "Running", True, BLACK)
    screen.blit(circle_text, (10, 10))
    screen.blit(x_point_text, (10, 40))
    screen.blit(pause_text, (10, 70))

    # Draw commentary for current particle
    current_particle = particles[commentary_index]
    enemies = [p for p in particles if p.is_circle != current_particle.is_circle]
    commentary = get_commentary(current_particle, enemies)
    # Split commentary into multiple lines if too long
    words = commentary.split()
    lines = []
    current_line = ""
    for word in words:
        test_line = current_line + word + " "
        if font.size(test_line)[0] < WIDTH - 20:
            current_line = test_line
        else:
            lines.append(current_line)
            current_line = word + " "
    lines.append(current_line)
    # Render each line
    for i, line in enumerate(lines):
        commentary_text = font.render(line, True, BLACK)
        screen.blit(commentary_text, (10, 100 + i * 30))


    pygame.display.flip()

def setup():
    pygame.display.set_caption("Particle Simulation")

async def main():
    setup()
    time_elapsed = 0
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    global paused
                    paused = not paused  # Toggle pause state
                elif event.key == pygame.K_q: # Add 'q' to quit
                    running = False
        circle_SV, x_point_SV = update_loop(time_elapsed)
        draw(circle_SV, x_point_SV)
        if not paused:
            time_elapsed += 1.0 / FPS
        clock.tick(FPS)
        await asyncio.sleep(0) # Use asyncio.sleep(0) to yield control back to the event loop

# Check if not running in a browser environment (like Colab)
if platform.system() != "Emscripten":
    # Get the current event loop and run the main coroutine
    loop = asyncio.get_event_loop()
    loop.create_task(main())
    # In a notebook, you might not need to explicitly run the loop.
    # The notebook environment manages it.
    # If you were in a script, you would use loop.run_forever()
else:
    # For Emscripten/browser environments, use ensure_future
    asyncio.ensure_future(main())